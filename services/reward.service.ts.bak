import prisma from '~/lib/prisma'
import { ethers } from 'ethers'
import { getProvider, getSigner, TRAVELFI_TOKEN_ABI, TRAVELFI_TOKEN_ADDRESS } from '~/lib/web3'

import type { RewardResult, WeeklyLimits, RewardType, TokenTransfer } from '~/types/reward'
import type { Contribution } from '@prisma/client'

export class RewardService {
  private static instance: RewardService
  private settings: Record<string, number> = {}
  private lastSettingsUpdate: number = 0

  private constructor() {}

  static getInstance(): RewardService {
    if (!RewardService.instance) {
      RewardService.instance = new RewardService()
    }
    return RewardService.instance
  }

  // Загрузить настройки из БД (с кешированием)
  private async loadSettings(): Promise<void> {
    const now = Date.now()
    // Обновляем настройки не чаще чем раз в 5 минут
    if (now - this.lastSettingsUpdate < 5 * 60 * 1000) return

    const settings = await prisma.adminSetting.findMany()
    this.settings = settings.reduce<Record<string, number>>((acc, setting) => {
      acc[setting.key] = Number(setting.value)
      return acc
    }, {})
    this.lastSettingsUpdate = now
  }

  // Получить настройку
  private async getSetting(key: string): Promise<number> {
    await this.loadSettings()
    return this.settings[key] || 0
  }

  // Проверить недельный лимит пользователя
  private async checkWeeklyLimit(userId: number): Promise<{ points: number; tokens: number }> {
    const weekAgo = new Date()
    weekAgo.setDate(weekAgo.getDate() - 7)

    const [contributions, transactions] = await Promise.all([
      prisma.contribution.findMany({
        where: { 
          userId,
          createdAt: { gte: weekAgo }
        }
      }),
      prisma.tokenTransaction.findMany({
        where: {
          userId,
          createdAt: { gte: weekAgo },
          status: 'completed'
        }
      })
    ])

    const weeklyPoints = contributions.reduce((sum, contrib) => sum + contrib.points, 0)
    const weeklyTokens = transactions.reduce((sum, tx) => sum + Number(tx.amount), 0)

    const pointsLimit = await this.getSetting('weeklyPointsLimit')
    const tokensLimit = await this.getSetting('weeklyTokensLimit')

    return {
      points: Math.max(0, pointsLimit - weeklyPoints),
      tokens: Math.max(0, tokensLimit - weeklyTokens)
    }
  }

  // Начислить награду
  private async grantReward(
    userId: number, 
    type: RewardType,
    points: number,
    tokens: number = 0,
    targetId?: number
  ): Promise<void> {
    const user = await prisma.user.findUnique({ 
      where: { id: userId },
      select: { id: true, points: true, walletAddress: true }
    })
    if (!user) throw new Error('User not found')

    // Если есть кошелек - начисляем только токены
    // Если нет - начисляем только баллы
    const rewardAmount = user.walletAddress ? tokens : points

    if (rewardAmount <= 0) return

    // Создаем транзакцию для атомарного обновления
    await prisma.$transaction(async (prisma) => {
      // Создаем запись о вкладе
      await prisma.contribution.create({
        data: {
          userId,
          type,
          points: user.walletAddress ? 0 : rewardAmount,  // Баллы только если нет кошелька
          ...(targetId ? { reportId: targetId } : {})
        }
      })

      if (user.walletAddress) {
        // Отправляем токены
        const provider = getProvider()
        const signer = getSigner(provider)
        const contract = new ethers.Contract(
          TRAVELFI_TOKEN_ADDRESS, 
          TRAVELFI_TOKEN_ABI, 
          signer
        )

        try {
          if (!contract?.transfer) {
            throw new Error('Contract or transfer method not available')
          }
          const tx = await contract.transfer(
            user.walletAddress,
            ethers.parseEther(rewardAmount.toString())
          )
          await tx.wait()
        } catch (error) {
          console.error('Failed to transfer tokens:', error)
          throw new Error('Token transfer failed')
        }
      } else {
        // Обновляем баллы только если нет кошелька
        await prisma.user.update({
          where: { id: userId },
          data: { points: user.points + rewardAmount }
        })
      }
    })
  }
  // Убрать награду
  private async revokeReward(userId: number, type: string, targetId?: number): Promise<void> {
    const contribution = await prisma.contribution.findFirst({
      where: {
        userId,
        type,
        ...(targetId ? { reportId: targetId } : {})
      }
    })

    if (!contribution) return

    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { points: true, walletAddress: true }
    })
    if (!user) return

    await prisma.$transaction(async (tx) => {
      // Удаляем запись о вкладе
      await tx.contribution.delete({
        where: { id: contribution.id }
      })

      // Отнимаем очки
      await tx.user.update({
        where: { id: userId },
        data: { points: Math.max(0, user.points - contribution.points) }
      })
    })

    // TODO: Implement token revocation if needed
  }

  // Публичные методы для разных типов наград

  async rewardWifiPoint(userId: number): Promise<RewardResult> {
    const { points, tokens } = await this.checkWeeklyLimit(userId)
    const settings = await Promise.all([
      this.getSetting('pointsWifiPoints'),
      this.getSetting('rewardWifiPoints')
    ])
    const [pointLimit, tokenLimit] = settings.map(s => s ?? 0)
    const pointReward = Math.min(points, pointLimit)
    const tokenReward = Math.min(tokens, tokenLimit)

    const finalPointReward = pointReward ?? 0
    const finalTokenReward = tokenReward ?? 0
    await this.grantReward(userId, 'add_wifi', finalPointReward, finalTokenReward)
    return { points: finalPointReward, tokens: finalTokenReward }
  }

  async rewardSecurityReport(userId: number, reportId: number): Promise<RewardResult> {
    const { points, tokens } = await this.checkWeeklyLimit(userId)
    const pointReward = Math.min(points, await this.getSetting('pointsSecurity'))
    const tokenReward = Math.min(tokens, await this.getSetting('rewardSecurity'))

    const finalPointReward = pointReward ?? 0
    const finalTokenReward = tokenReward ?? 0
    await this.grantReward(userId, 'security_report', finalPointReward, finalTokenReward, reportId)
    return { points: finalPointReward, tokens: finalTokenReward }
  }

  async rewardReview(userId: number): Promise<RewardResult> {
    const { points, tokens } = await this.checkWeeklyLimit(userId)
    const pointReward = Math.min(points, await this.getSetting('pointsReview'))
    const tokenReward = Math.min(tokens, await this.getSetting('rewardReview'))

    const finalPointReward = pointReward ?? 0
    const finalTokenReward = tokenReward ?? 0
    await this.grantReward(userId, 'add_review', finalPointReward, finalTokenReward)
    return { points: finalPointReward, tokens: finalTokenReward }
  }

  async rewardEsimProvider(userId: number): Promise<RewardResult> {
    const { points, tokens } = await this.checkWeeklyLimit(userId)
    const pointReward = Math.min(points, await this.getSetting('pointsEsim'))
    const tokenReward = Math.min(tokens, await this.getSetting('rewardEsim'))

    const finalPointReward = pointReward ?? 0
    const finalTokenReward = tokenReward ?? 0
    await this.grantReward(userId, 'add_esim', finalPointReward, finalTokenReward)
    return { points: finalPointReward, tokens: finalTokenReward }
  }

  async revokeSecurityReport(userId: number, reportId: number): Promise<void> {
    await this.revokeReward(userId, 'security_report', reportId)
  }

  async revokeReview(userId: number): Promise<void> {
    await this.revokeReward(userId, 'add_review')
  }

  // Конвертация баллов в токены при подключении кошелька
  async convertPointsToTokens(userId: number, walletAddress: string): Promise<void> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { points: true }
    })
    if (!user) throw new Error('User not found')

    const points = user.points
    const userPoints = user.points ?? 0
    if (userPoints <= 0) return

    const provider = getProvider()
    const signer = getSigner(provider)
    if (!ethers?.Contract) {
      throw new Error('ethers.Contract is not available')
    }
    const contract = new ethers.Contract(
      TRAVELFI_TOKEN_ADDRESS,
      TRAVELFI_TOKEN_ABI,
      signer
    )

    // Конвертируем все баллы в токены 1:1
    try {
      if (!contract?.transfer) {
        throw new Error('Contract or transfer method not available')
      }
      if (!contract?.transfer) {
        throw new Error('Contract or transfer method not available')
      }
      const tx = await contract.transfer(
        walletAddress,
        ethers.parseEther(userPoints.toString())
      )
      await tx.wait()

      // Обнуляем баллы после успешной конвертации
      await prisma.user.update({
        where: { id: userId },
        data: { 
          points: 0,
          walletAddress
        }
      })
    } catch (error) {
      console.error('Failed to convert points to tokens:', error)
      throw new Error('Token conversion failed')
    }
  }
}

// Экспортируем синглтон
export const rewardService = RewardService.getInstance()